package com.kedu.dao;

import java.util.List;
import java.util.Map;

import org.mybatis.spring.SqlSessionTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import com.kedu.dto.MessagesDTO;

@Repository // Component 스캔으로 인스턴스 쉽게 만들 수 있음 @Controller 처럼
// Component 라고 해도 되지만, dao는 보통 Repository를 사용한다.
public class MessagesDAO {

	@Autowired
	private SqlSessionTemplate mybatis;
	
	public int insert(MessagesDTO dto) {
		// 첫번째 파라미터 : 사용할 매퍼의 namespace
		return mybatis.insert("Messages.insert", dto);	
	}
	
	public int deleteBySeq(int seq) {
		return mybatis.delete("Messages.deleteBySeq", seq);
	}
	
	public int updateBySeq(MessagesDTO dto) {
		return mybatis.update("Messages.updateBySeq", dto);
	}
	
	public List<MessagesDTO> selectAll(){
		return mybatis.selectList("Messages.selectAll");
	}
	
	public List<MessagesDTO> selectBy(Map<String,String> param){
		
		return mybatis.selectList("Messages.selectBy", param);
	}
//	public int insert(MessagesDTO dto){ 
//		// checked Exception, runtime Exception(unChecnked Exception)
//		// jdbc 는 checked Exception 으로 바꿔버림
//		String sql = "insert into messages values(messages_seq.nextval, ?, ?)";
//
//		// 첫번째 인자 : sql, 두번째부터 : 가변 인자
//		return jdbc.update(sql, dto.getSender(), dto.getMessage());
//
//		// try with resource, connection, preparedStatment 싹 만들어줌.
//	}
//
//	public int deleteBySeq(int seq) {
//		String sql = "delete from messages where seq = ?";
//		return jdbc.update(sql, seq);
//	}
//
//	public int updateBySeq(MessagesDTO dto) {
//		String sql = "update messages set sender = ?, message = ? where seq = ?";
//		return jdbc.update(sql, dto.getSender(), dto.getMessage(), dto.getSeq());
//	}
//
//	// 경우의 수 2가지
//	// 1. DB 테이블 컬럼명 == DTO의 멤버필드명이 동일할 때
//	public List<MessagesDTO> selectAll(){
//		String sql = "select * from messages";
//		return jdbc.query(sql, new BeanPropertyRowMapper<>(MessagesDTO.class));	
//	}
//
//	// 2.DB 테이블 컬럼명 != DTO의 멤버필드명이 동일하지 않을 때 - 콜백 함수가 들어가야 됨.
//	// 자바 언어 특성상 콜백 함수를 값으로 바로 사용하지 못하므로 
//	// 인스턴스를 생성해서 그 안에 콜백 함수를 만들어서 전달해야 됨.
//	public List<MessagesDTO> selectAll2(){
//		String sql = "select * from messages";
//		// RowMapper() 는 interface 이므로 추상 클래스인 것을 알 수 있다.
//		// 추상클래스는 추상메서드를 포함하고 있어서 추상메서드를 오버라이딩 하지 않는 이상 new 할 수 없다.
//		
//		// 익명 클래스 방식 new RowMapper(){} 바로 중괄호 여는 것.
//		// new RowMapper(){} 바로 중괄호 여는 것.,
//		// 아래처럼 사용하면 클래스 이름없이 만들고, RowMapper를 상속받은 것이므로 익명 클래스라고 한다.
//		return jdbc.query(sql, new RowMapper<MessagesDTO>() {
//			@Override
//			public MessagesDTO mapRow(ResultSet rs, int rowNum) throws SQLException {
//				MessagesDTO dto = new MessagesDTO();
//				dto.setSeq(rs.getInt("seq"));
//				dto.setSender(rs.getString("sender"));
//				dto.setMessage(rs.getString("message"));
//				return dto;
//				// RowMapper는 하나의 dto를 꺼내면 바로 list에 저장, 행이 없을 때까지 알아서 반복한다.
//			}
//		});
//	}
//	
//	public List<MessagesDTO> selectAllBySeq(int seq){
//		String sql = "select * from messages where seq = ?";
//		
//		return jdbc.query(sql, new RowMapper<MessagesDTO>() {
//			@Override
//			public MessagesDTO mapRow(ResultSet rs, int rowNum) throws SQLException {
//				MessagesDTO dto = new MessagesDTO();
//				dto.setSeq(rs.getInt("seq"));
//				dto.setSender(rs.getString("sender"));
//				dto.setMessage(rs.getString("message"));
//				return dto;
//			}
//		}, seq);
//	}
//	
//	public int count() {
//		String sql = "select count(*) from messages";
//		return jdbc.queryForObject(sql, Integer.class);
//	}
//
//
//	// updete() 파라미터 보면 파라미터 수가 다양함
//	// 가변 인자 파라미터 : Object... args / 인자로 몇개가 올지 모를 때 사용.
//	// 가변 인자 파라미터는 무조건 마지막 파라미터 자리에 쓰여야 됨.
//
//	/*
//	 * @Autowired private BasicDataSource bds;
//	 * 
//	 * public int insert(MessagesDTO dto) throws Exception{ String sql =
//	 * "insert into messages values(messages_seq.nextval, ?, ?)"; try(Connection con
//	 * = bds.getConnection(); PreparedStatement pst = con.prepareStatement(sql)){
//	 * 
//	 * pst.setString(1, dto.getSender()); pst.setString(2, dto.getMessage()); return
//	 * pst.executeUpdate(); } }
//	 * 
//	 * public List<MessagesDTO> selectAll() throws Exception{ String sql =
//	 * "select * from messages";
//	 * 
//	 * try(Connection con = bds.getConnection(); PreparedStatement pst =
//	 * con.prepareStatement(sql); ResultSet rs = pst.executeQuery();){
//	 * 
//	 * List<MessagesDTO> list = new ArrayList<>();
//	 * 
//	 * while(rs.next()) { int seq = rs.getInt("seq"); String sender =
//	 * rs.getString("sender"); String message = rs.getString("message");
//	 * 
//	 * list.add(new MessagesDTO(seq, sender, message)); } return list; } }
//	 * 
//	 * public int deleteBySeq(int seq) throws Exception{ String sql =
//	 * "delete from messages where seq = ?"; try(Connection con =
//	 * bds.getConnection(); PreparedStatement pst = con.prepareStatement(sql);){
//	 * pst.setInt(1, seq); return pst.executeUpdate(); } }
//	 * 
//	 * public int updateBySeq(MessagesDTO dto) throws Exception{ String sql =
//	 * "update messages set sender=?, message=? where seq=?"; try(Connection con =
//	 * bds.getConnection(); PreparedStatement pst = con.prepareStatement(sql);){
//	 * pst.setString(1, dto.getSender()); pst.setString(2, dto.getMessage());
//	 * pst.setInt(3, dto.getSeq()); return pst.executeUpdate(); } }
//	 */
}
